# 11. Краткий обзор стандартной библиотеки — Часть II

[Оригинал](https://docs.python.org/3.12/tutorial/stdlib2.html)

Этот второй тур охватывает более продвинутые модули, поддерживающие профессиональные потребности программирования. Эти модули редко встречаются в небольших сценариях.

## 11.1. Форматирование вывода

Модуль `reprlib` предоставляет версию функции `repr()` с ограничением длины отображаемых контейнеров большого размера или глубоко вложенной структуры:

```python
import reprlib
reprlib.repr(set('supercalifragilisticexpialidocious'))
# {'a', 'c', 'd', 'e', 'f', 'g', ...}
```

Модуль `pprint` предлагает расширенный контроль над печатью встроенных объектов и объектов, определенных пользователем, таким образом, чтобы результат был читаем интерпретатором. Если результат длиннее одной строки, добавляется разбиение строк и отступы для ясности структуры:

```python
import pprint
t = [[[['black', 'cyan'], 'white', ['green', 'red']],
       [['magenta', 'yellow'], 'blue']]]
pprint.pprint(t, width=30)
# [[[['black', 'cyan'],
#    'white',
#    ['green', 'red']],
#   [['magenta', 'yellow'],
#    'blue']]]
```

Модуль `textwrap` позволяет форматировать абзацы текста, чтобы они соответствовали заданной ширине экрана:

```python
import textwrap
doc = """Метод wrap() аналогичен методу fill(), за исключением того, что возвращает список строк вместо одного большого строки с разделителями."""
print(textwrap.fill(doc, width=40))
# Метод wrap() аналогичен методу
# fill(), за исключением того, что
# возвращает список строк вместо
# одного большого строки с
# разделителями.
```

Модуль `locale` обеспечивает доступ к базам данных форматов данных, специфичных для культуры. Атрибут группировки функции формата локали предоставляет прямой способ форматирования чисел с разделителями групп:

```python
import locale
locale.setlocale(locale.LC_ALL, 'English_United States.1252')
conv = locale.localeconv()
x = 1234567.8
locale.format_string("%d", x, grouping=True)
# '1,234,567'
locale.format_string("%s%.*f", (conv['currency_symbol'], conv['frac_digits'], x), grouping=True)
# '$1,234,567.80'
```

## 11.2. Шаблонизация

Модуль `string` включает универсальный класс шаблона `Template`, подходящий для редактирования конечными пользователями. Это позволяет пользователям настраивать приложения без изменения самого приложения.

Шаблоны используют имена заполнителей, начинающиеся с символа `$`. Окружая заполнитель фигурными скобками, можно следовать дополнительным буквенно-цифровым символам без пробелов между ними. Для экранирования одиночного знака доллара используется запись `$$`.

Пример использования класса `Template`:

```python
from string import Template
t = Template('$villagefolk send $$10 to $cause.')
t.substitute(village='Nottingham', cause='the ditch fund')
# 'Nottinghamfolk send $10 to the ditch fund.'
```

Метод `substitute()` вызывает исключение `KeyError`, если заполнитель отсутствует в словаре или аргументе ключевого слова. В случае приложений слияния почты, где данные пользователей могут быть неполными, предпочтительнее использовать метод `safe_substitute()`, который оставляет заполнители неизмененными, если данные отсутствуют:

```python
t = Template('Вернуть $item владельцу $owner.')
d = dict(item='неподъемный лебедь')
t.substitute(d)
# Traceback (most recent call last):
# KeyError: 'owner'
t.safe_substitute(d)
# 'Вернуть неподъемный лебедь владельцу $owner.'
```

Подклассы шаблонов могут указывать собственный разделитель. Например, утилита пакетного переименования фотографий может выбрать использование знаков процента (`%`) для заполнителей даты, номера последовательности изображений или формата файла:

```python
import time, os.path
photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
class BatchRename(Template):
    delimiter = '%'
fmt = input('Введите стиль переименования (%d-дата %n-порядковый номер %f-формат): ')
# Enter rename style (%d-date %n-seqnum %f-format): Ashley_%n%f
t = BatchRename(fmt)
date = time.strftime('%d%b%y')
for i, filename in enumerate(photofiles):
    base, ext = os.path.splitext(filename)
    newname = t.substitute(d=date, n=i, f=ext)
    print(f'{filename} --> {newname}')
# img_1074.jpg --> Ashley_0.jpg
# img_1076.jpg --> Ashley_1.jpg
# img_1077.jpg --> Ashley_2.jpg
```

## 11.3. Работа с бинарными структурами данных

Модуль `struct` предоставляет функции `pack()` и `unpack()` для работы с двоичными записями переменной длины. Следующий пример показывает, как перебирать заголовочную информацию в файле ZIP без использования модуля `zipfile`. Кодировки `"H"` и `"I"` представляют двухбайтовые и четырехбайтовые беззнаковые числа соответственно. Символ `<` означает стандартный размер и порядок байтов little-endian:

```python
import struct

with open('myfile.zip', 'rb') as f:
    data = f.read()

start = 0
for i in range(3):
    start += 14
    fields = struct.unpack('<IIIHH', data[start:start+16])
    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields
    start += 16
    filename = data[start:start+filenamesize]
    start += filenamesize
    extra = data[start:start+extra_size]
    print(filename, hex(crc32), comp_size, uncomp_size)
    start += extra_size + comp_size
```

## 11.4. Многопоточность

Многопоточное выполнение позволяет отделять задачи, которые не зависят друг от друга последовательно. Потоки используются для повышения отзывчивости приложений, принимающих пользовательский ввод, пока другие задачи выполняются в фоновом режиме. Еще одно применение — параллельное выполнение ввода-вывода вместе с вычислениями в другом потоке.

Следующий код демонстрирует, как модуль многопоточности высокого уровня запускает фоновые задачи параллельно с основной программой:

```python
import threading, zipfile

class AsyncZip(threading.Thread):
    def __init__(self, infile, outfile):
        threading.Thread.__init__(self)
        self.infile = infile
        self.outfile = outfile

    def run(self):
        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
        f.write(self.infile)
        f.close()
        print('Фоновый архив завершён:', self.infile)

background = AsyncZip('mydata.txt', 'myarchive.zip')
background.start()
print('Основная программа продолжает выполняться в переднем плане.')
background.join()
print('Главная программа дождалась завершения фона.')
```

Основной проблемой многопоточных приложений является координация потоков, совместно использующих ресурсы. Модуль `threading` предоставляет примитивы синхронизации, такие как блокировки, события, условные переменные и семафоры.

При проектировании многопоточных приложений рекомендуется сосредоточить весь доступ к ресурсам в одном потоке и использовать модуль очередей `queue` для передачи запросов другим потокам. Приложения, использующие объекты очереди для межпоточного взаимодействия и координации, легче проектируются, читаются и надежны.

## 11.5. Логгирование

Модуль `logging` предоставляет полную систему ведения журнала событий. По умолчанию информационные и отладочные сообщения подавляются, а вывод направляется в stderr. Другие варианты включают отправку сообщений через электронную почту, датаграммы, сокеты или веб-сервер HTTP.

Простое ведение журнала:

```python
import logging
logging.debug('Отладка')
logging.info('Информационное сообщение')
logging.warning('Предупреждение: файл конфигурации %s не найден', 'server.conf')
logging.error('Ошибка произошла')
logging.critical('Критическая ошибка — завершение работы')
```

Это выводит следующее:

```
WARNING:root:Предупреждение: файл конфигурации server.conf не найден
ERROR:root:Ошибка произошла
CRITICAL:root:Критическая ошибка — завершение работы
```

Система логгирования поддерживает различные уровни приоритета: DEBUG, INFO, WARNING, ERROR и CRITICAL.

## 11.6. Слабые ссылки

Python автоматически управляет памятью путем подсчета ссылок и сборки мусора. Иногда возникает необходимость отслеживать объект до тех пор, пока он используется кем-то еще. Однако простое отслеживание создает ссылку, делающую объект постоянным. Модуль `weakref` предоставляет инструменты для отслеживания объектов без создания ссылки. Когда объект больше не нужен, он автоматически удаляется из таблицы слабых ссылок и вызывается обратный вызов объекта слабой ссылки.

Типичное применение — кэширование дорогостоящих объектов:

```python
import weakref, gc
class A:
    def __init__(self, value):
        self.value = value
    def __repr__(self):
        return str(self.value)

a = A(10)
d = weakref.WeakValueDictionary()
d['primary'] = a
d['primary']
# 10
del a
gc.collect()
d['primary']
# Traceback (most recent call last):
# ...
# KeyError: 'primary'
```

## 11.7. Инструменты для работы со списками

Многие потребности в структуре данных удовлетворяются встроенным типом списка. Но иногда требуются альтернативные реализации с различными компромиссами производительности.

Модуль `array` предоставляет тип массива, подобный списку, хранящий однородные данные компактнее обычного списка объектов Python:

```python
from array import array
a = array('H', [4000, 10, 700, 22222])
sum(a)
# 26932
a[1:3]
# array('H', [10, 700])
```

Модуль `collections` предоставляет двунаправленную очередь `deque`, подобную списку, но с более быстрым добавлением и извлечением элементов слева, хотя медленнее ищет элементы посередине. Этот объект подходит для реализации очередей и поиска в ширину по дереву:

```python
from collections import deque
d = deque(['task1', 'task2', 'task3'])
d.append('task4')
print('Обработка', d.popleft())
# Обработка task1
```

Кроме альтернативных реализаций списков библиотека также предлагает дополнительные инструменты, такие как модуль `bisect` для манипуляций с отсортированными списками:

```python
import bisect
scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
bisect.insort(scores, (300, 'ruby'))
scores
# [(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]
```

Модуль `heapq` реализует структуру данных куча поверх обычных списков. Минимальное значение всегда находится в позиции нуля. Эта реализация полезна, когда нужно многократно получать наименьший элемент без полного сортирования всего списка:

```python
from heapq import heapify, heappop, heappush
data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
heapify(data)
heappush(data, -5)
[heappop(data) for _ in range(3)]
# [-5, 0, 1]
```

## 11.8. Десятичная арифметика с плавающей точкой

Модуль `decimal` предоставляет тип данных `Decimal` для десятичной арифметики с плавающей точкой. Класс особенно полезен для финансовых приложений и других случаев, когда требуется точное представление десятичных дробей, управление точностью, округление согласно юридическим требованиям, отслеживание значащих цифр или соответствие ожиданиям пользователей относительно результатов ручных расчетов.

Например, расчет налога в размере 5% на телефонный счет в 70 центов дает разные результаты в десятичном представлении и в двоичном формате с плавающей точкой. Разница становится существенной после округления до ближайшего цента:

```python
from decimal import *
round(Decimal('0.70') * Decimal('1.05'), 2)
# Decimal('0.74')
round(.70 * 1.05, 2)
# 0.73
```

Класс `Decimal` сохраняет завершающий ноль, автоматически определяя четыре значимых цифры из исходных значений с двумя знаками точности. Тип `Decimal` воспроизводит расчеты вручную и избегает проблем, возникающих, когда двоичная форма представления не может точно представить десятичные величины.

Точный результат делает возможным операции сравнения равенства и нахождения остатка, невозможные в двоичной форме с плавающей точкой:

```python
Decimal('1.00') % Decimal('.10')
# Decimal('0.00')
1.00 % .10
# 0.09999999999999995
```

Модуль `decimal` предоставляет арифметику с произвольной точностью:

```python
getcontext().prec = 36
Decimal(1) / Decimal(7)
# Decimal('0.142857142857142857142857142857142857')
```
