# 9. Классы

[Оригинал](https://docs.python.org/3.12/tutorial/classes.html)

Классы позволяют объединять данные и функциональность вместе. Создание нового класса создает новый тип объекта, позволяя создавать экземпляры данного типа. Каждый экземпляр класса может иметь атрибуты для хранения состояния и методы для изменения этого состояния.

## 9.1. О названиях и объектах

Объекты имеют индивидуальность, и одно имя может относиться к разным объектам. Это называется псевдонимизацией. Для неизменяемых типов (числа, строки, кортежи) псевдонимизация не вызывает проблем, однако для изменяемых объектов (списки, словари) она может привести к неожиданному поведению.

## 9.2. Пространства имен и области видимости Python

Пространство имен — это отображение имен на объекты. Примеры пространств имен включают встроенные имена функций (`abs()`), глобальные имена модуля и локальные имена функции. Атрибуты объекта также образуют пространство имен.

При поиске атрибута сначала проверяется локальное пространство имен, затем пространства имен вложенных функций, далее глобальное пространство имен модуля и наконец пространство имен встроенных имен.

### 9.2.1. Пример областей видимости и пространств имен

Пример демонстрирует работу различных областей видимости и использование операторов `global` и `nonlocal`.

```python
def scope_test():
    def do_local():
        spam = "local spam"

    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"

    def do_global():
        global spam
        spam = "global spam"

    spam = "test spam"
    do_local()
    print("После локального присваивания:", spam)
    do_nonlocal()
    print("После нелокального присваивания:", spam)
    do_global()
    print("После глобального присваивания:", spam)

scope_test()
print("В глобальной области видимости:", spam)
```

Результат выполнения примера:

```
После локального присваивания: test spam
После нелокального присваивания: nonlocal spam
После глобального присваивания: nonlocal spam
В глобальной области видимости: global spam
```

Локальное присвоение не меняет значение `spam`, поскольку оно действует только внутри своей области видимости. Нелокальное присвоение изменяет значение `spam` во внешней области видимости, а глобальное присваивание изменяет значение в пространстве имен модуля.

## 9.3. Первый взгляд на классы

Классы вводят новую синтаксическую конструкцию и три новых типа объектов: класс, объект класса и экземпляр класса.

### 9.3.1. Синтаксис определения классов

Простейшая форма определения класса выглядит следующим образом:

```python
class ClassName:
    <statement-1>
    ...
    <statement-N>
```

Определение класса должно выполняться до его использования. Внутри класса обычно определяются методы, хотя другие инструкции тоже допустимы.

### 9.3.2. Объекты классов

Классовые объекты поддерживают два вида операций: доступ к атрибутам и создание экземпляров.

Атрибуты класса доступны через стандартную запись `<объект>.<имя>`. Например, если класс определен так:

```python
class MyClass:
    """Простой пример класса"""
    i = 12345

    def f(self):
        return 'hello world'
```

То `MyClass.i` и `MyClass.f` являются корректными обращениями к атрибутам класса, возвращая целое число и функцию соответственно.

Создание экземпляра класса выполняется вызовом самого класса:

```python
x = MyClass()
```

Это создает пустой объект-экземпляр. Обычно классы определяют метод `__init__`, выполняющий инициализацию экземпляра.

### 9.3.3. Экземпляры классов

Экземпляры классов понимают только операции обращения к атрибутам. Есть два типа атрибутов: данные и методы.

Данные атрибуты соответствуют полям экземпляра ("переменным экземпляра") в языках вроде Smalltalk и C++. Они создаются автоматически при первом присваивании.

Методы представляют собой функции, принадлежащие классу. Методы вызываются через обращение к ним через экземпляр класса.

### 9.3.4. Объекты методов

Обычно метод сразу же вызывается после привязки:

```python
x.f()
```

Однако метод можно сохранить отдельно и вызвать позже:

```python
xf = x.f
while True:
    print(xf())
```

Метод принимает первым аргументом сам объект, к которому относится. Вызов метода эквивалентен вызову соответствующей функции с объектом перед всеми аргументами.

### 9.3.5. Переменные класса и экземпляра

Переменные класса используются для общих данных всех экземпляров, тогда как переменные экземпляра уникальны для каждого экземпляра.

Например:

```python
class Dog:
    kind = 'canine'          # общая переменная класса

    def __init__(self, name):
        self.name = name      # уникальная переменная экземпляра
```

Использование общей переменной приведет к одинаковым результатам для разных экземпляров:

```python
d = Dog('Fido')
e = Dog('Buddy')
d.kind                   # общее свойство
'canine'
e.kind                   # общее свойство
'canine'
d.name                   # уникальное свойство
'Fido'
e.name                   # уникальное свойство
'Buddy'
```

Важно избегать использования общих изменяемых объектов (например, списков) в качестве переменных класса, иначе они будут совместно использоваться всеми экземплярами.

## 9.4. Случайные замечания

Если один и тот же атрибут существует одновременно в классе и экземпляре, приоритет имеет экземпляр.

Доступ к данным атрибутам возможен как изнутри методов, так и извне. Однако изменение данных атрибутов снаружи может нарушить внутренние инварианты, поддерживаемые методами.

Имена методов и атрибутов начинаются с префикса `_` считаются внутренними деталями реализации и могут меняться без предупреждения.

## 9.5. Наследование

Поддерживается наследование классов. Определение производного класса выглядит так:

```python
class DerivedClassName(BaseClassName):
    <statement-1>
    ...
    <statement-N>
```

Производный класс наследует поведение базового класса. Если атрибут не найден в производном классе, поиск продолжается вверх по цепочке базовых классов.

### 9.5.1. Множественное наследование

Допустимо множественное наследование:

```python
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    ...
    <statement-N>
```

Поиск атрибутов происходит слева направо, глубина поиска ограничена одним проходом по иерархии.

## 9.6. Приватные переменные

Приватных переменных, недоступных вне объекта, в Python нет. Но есть соглашение: имена, начинающиеся с одного подчеркивания (например, `_spam`), считаются неприватными частями API и могут изменяться без уведомления.

Для предотвращения конфликтов имен используется механизм переименования имен (name mangling). Именам вида `__spam` добавляется префикс имени текущего класса.

## 9.7. Разное

Иногда полезно создать структуру данных наподобие записей в Pascal или структур в C. В Python для этого удобно использовать модуль `dataclasses`:

```python
from dataclasses import dataclass

@dataclass
class Employee:
    name: str
    dept: str
    salary: int
```

Также возможно реализовать собственные итераторы путем переопределения специальных методов `__iter__` и `__next__`.

## 9.8. Итерации

Большинство контейнерных объектов можно перебирать циклом `for`. За кулисами цикл вызывает метод `iter()` контейнера, который возвращает итератор с методом `__next__()`.

## 9.9. Генерация значений (генераторы)

Генераторы упрощают создание итераторов. Генераторная функция содержит оператор `yield`, который временно останавливает выполнение функции и возвращает текущее значение.

Пример генератора:

```python
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
```

## 9.10. Выражения генераторов

Выражения генераторов похожи на выражения списков, но используют круглые скобки и создают генератор, а не список. Они компактнее и экономичнее по памяти.

Примеры выражений генераторов:

```python
sum(i*i for i in range(10))
sum(x*y for x,y in zip(xvec, yvec))
```
