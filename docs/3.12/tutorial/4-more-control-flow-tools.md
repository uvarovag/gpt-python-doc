# 4. Дополнительные средства управления потоком выполнения

[Оригинал](https://docs.python.org/3.12/tutorial/controlflow.html)

Python поддерживает несколько управляющих конструкций помимо уже рассмотренной инструкции `while`.

## 4.1. Инструкция `if`

Инструкция `if` позволяет выбирать один из нескольких вариантов действий в зависимости от условия. Например:

```python
x = int(input("Пожалуйста введите целое число: "))
if x < 0:
   x = 0
   print('Отрицательное значение заменено нулём')
elif x == 0:
   print('Ноль')
elif x == 1:
   print('Одно')
else:
   print('Больше одного')
# Больше одного
```

Количество блоков `elif` неограниченно, блок `else` необязателен. Конструкция `if ... elif ... elif ...` аналогична операторам `switch/case`, используемым в других языках программирования.

Также полезно использовать инструкцию `match`. См. раздел [инструкции match](#tut-match).

## 4.2. Инструкция `for`

Цикл `for` отличается от аналогичных циклов в C/Pascal. Вместо арифметической прогрессии чисел цикл проходит элементы любой последовательности (списка, строки) в порядке следования элементов. Например:

```python
words = ['кошка', 'окно', 'дефенестрация']
for w in words:
   print(w, len(w))
# кошка 3
# окно 6
# дефенестрация 12
```

Изменение коллекции во время её обхода может привести к ошибкам. Лучше создать копию или новую коллекцию:

```python
users = {'Ханс': 'активный', 'Элеонор': 'неактивная', 'Кэйтаро': 'активный'}

# Стратегия: обойти копию
for user, status in users.copy().items():
    if status == 'неактивная':
        del users[user]

# Стратегия: создать новую коллекцию
active_users = {}
for user, status in users.items():
    if status == 'активный':
        active_users[user] = status
```

## 4.3. Функция `range()`

Функция `range()` генерирует последовательность целых чисел. Она полезна для итерации по числам:

```python
for i in range(5):
   print(i)
# 0
# 1
# 2
# 3
# 4
```

Можно задать начальное и конечное значения, а также шаг:

```python
list(range(5, 10)) # [5, 6, 7, 8, 9]
list(range(0, 10, 3)) # [0, 3, 6, 9]
list(range(-10, -100, -30)) # [-10, -40, -70]
```

Для перебора индексов списка используйте комбинацию функций `range()` и `len()`:

```python
a = ['Мэри', 'имела', 'маленького', 'ягнёнка']
for i in range(len(a)):
   print(i, a[i])
# 0 Мэри
# 1 имела
# 2 маленького
# 3 ягнёнка
```

Однако удобнее использовать функцию `enumerate()` (см. раздел [Техники работы с циклами](datastructures.html#tut-loopidioms)).

При печати объекта типа `range()` выводится объект диапазона:

```python
range(10) # range(0, 10)
```

Объект, возвращаемый функцией `range()`, ведёт себя подобно списку, но фактически не создаёт список, экономя память.

## 4.4. Инструкции `break` и `continue`

Инструкция `break` прерывает ближайший внутренний цикл (`for` или `while`), инструкция `continue` пропускает текущее повторение цикла и переходит к следующему:

```python
for num in range(2, 10):
   if num % 2 == 0:
       print(f"Найдено чётное число {num}")
       continue
   print(f"Найдено нечётное число {num}")
# Найдено чётное число 2
# Найдено нечётное число 3
# Найдено чётное число 4
# Найдено нечётное число 5
# Найдено чётное число 6
# Найдено нечётное число 7
# Найдено чётное число 8
# Найдено нечётное число 9
```

## 4.5. Блок `else` в циклах

У инструкций `for` и `while` может присутствовать блок `else`, выполняемый после завершения цикла, если не было выполнено условие выхода через `break`:

```python
for n in range(2, 10):
   for x in range(2, n):
       if n % x == 0:
           print(n, 'равно', x, '*', n // x)
           break
   else:
       print(n, 'является простым числом')
# 2 является простым числом
# 3 является простым числом
# 4 равно 2 * 2
# 5 является простым числом
# 6 равно 2 * 3
# 7 является простым числом
# 8 равно 2 * 4
# 9 равно 3 * 3
```

Обратите внимание, что блок `else` относится именно к циклу `for`, а не к условию внутри цикла.

## 4.6. Инструкция `pass`

Инструкция `pass` ничего не делает. Используется там, где синтаксически необходима инструкция, но программа не должна выполнять никаких действий. Например:

```python
while True:
   pass  # Ожидание прерывания клавиатуры (Ctrl+C)
```

Часто используется для минимальных классов:

```python
class MyEmptyClass:
   pass
```

Или как заглушка при разработке нового кода:

```python
def initlog(*args):
   pass  # Нужно реализовать позже!
```

## 4.7. Инструкция `match`

Инструкция `match` сравнивает выражение с последовательностью шаблонов, определяемых одним или несколькими блоками `case`. Это похоже на оператор `switch` в других языках, но ближе к сопоставлению паттернов в Rust/Haskell. Выполняется первый совпадающий шаблон, извлекая компоненты выражения в переменные:

Простейшая форма сравнения значений с литеральными константами:

```python
def http_error(status):
    match status:
        case 400:
            return "Некорректный запрос"
        case 404:
            return "Не найдено"
        case _:
            return "Что-то пошло не так с интернетом"
```

Шаблоны могут объединяться оператором `|` («или»):

```python
case 401 | 403 | 404:
    return "Доступ запрещён"
```

Паттерны могут распаковывать структуры данных и связывать переменные:

```python
match point:
    case (0, 0):
        print("Начало координат")
    case (x, y):
        print(f"X={x}, Y={y}")
    case _:
        raise ValueError("Это не точка")
```

Допустимо использование именованных атрибутов объектов:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def where_is(point):
    match point:
        case Point(x=0, y=0):
            print("Начало координат")
        case Point(x=x, y=y):
            print(f"X={x}, Y={y}")
        case _:
            print("Где-то ещё")
```

Поддерживаются вложенные паттерны, расширенная распаковка кортежей/список, сопоставление словарей и другие возможности.

Подробности см. в PEP 636.

## 4.8. Определение функций

Пример функции, печатающей числа ряда Фибоначчи до заданного предела:

```python
def fib(n):
    """Печатает ряд Фибоначчи меньше n."""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a + b
    print()

fib(2000)
# 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

Ключевые особенности:

- Инструкция `return` возвращает результат из функции.
- Метод `.append()` добавляет элемент в конец списка.

## 4.9. Более подробно о функциях

### 4.9.1. Значения аргументов по умолчанию

Можно указать аргументы по умолчанию, позволяя вызывать функцию с меньшим количеством аргументов:

```python
def ask_ok(prompt, retries=4, reminder='Попробуйте снова'):
    ...
```

Примеры вызова:

```python
ask_ok('Вы действительно хотите выйти?')
ask_ok('Перезаписать файл?', 2)
ask_ok('Перезаписать файл?', 2, 'Только да или нет!')
```

Значение по умолчанию вычисляется единожды при определении функции, что важно учитывать при работе с изменяемыми объектами.

### 4.9.2. Аргументы-ключевые слова

Функции могут принимать ключевые аргументы вида `ключ=значение`:

```python
def parrot(voltage, state='жёсткий', action='вуум', type='Голубой норвежский'):
    ...
```

Примеры корректных вызовов:

```python
parrot(1000)
parrot(voltage=1000000, action='ВООООМ')
parrot(action='ВООООМ', voltage=1000000)
parrot('миллион', 'лишённый жизни', 'подскочить')
parrot('тысяча', state='толкает маргаритки')
```

### 4.9.3. Специальные параметры

Параметры функции могут иметь разные типы передачи: позиционные, позиционно-ключевые или исключительно ключевые.

### 4.9.4. Произвольные списки аргументов

Функция может принимать произвольное количество аргументов, упаковываемых в кортеж:

```python
def concat(*args, sep="/"):
    return sep.join(args)

concat("земля", "марс", "венера") # земля/марс/венера
concat("земля", "марс", "венера", sep=".") # земля.марс.венера
```

### 4.9.5. Распаковка аргументов

Если аргументы находятся в списке или кортеже, их можно передать в виде отдельных аргументов с помощью оператора `*`:

```python
list(range(3, 6)) # [3, 4, 5]
args = [3, 6]
list(range(*args)) # [3, 4, 5]
```

Аналогично работает распаковка словаря с использованием оператора `**`:

```python
def parrot(voltage, state='жёсткий', action='вуум'):
    ...

d = {"voltage": "четыре миллиона", "state": "умерший"}
parrot(**d)
```

### 4.9.6. Лямбда-выражения

Лямбда-функции позволяют создавать небольшие анонимные функции прямо в выражении:

```python
pairs = [(1, 'один'), (2, 'два'), (3, 'три')]
pairs.sort(key=lambda pair: pair[1])
```

### 4.9.7. Строки документации

Документация функции задаётся строковым литералом сразу после определения функции:

```python
def my_function():
    """
    Ничего не делает, но документирует это.

    Нет, правда, оно вообще ничего не делает.
    """
    pass
```

### 4.9.8. Аннотации функций

Аннотации предоставляют дополнительную метаданные о типах аргументов и возвращаемого значения:

```python
def f(ham: str, eggs: str = 'яйца') -> str:
    print("Аннотации:", f.__annotations__)
    print("Аргументы:", ham, eggs)
    return ham + ' и ' + eggs
```

## 4.10. Интерлюдия: стиль написания кода

Рекомендуемые правила стиля изложены в PEP 8:

- Используйте отступы в четыре пробела.
- Ограничивайте длину строк до 79 символов.
- Разделяйте классы и большие блоки кода пустыми строками.
- Комментарии лучше размещать отдельно.
- Применяйте строки документации.
- Называйте классы в стиле UpperCamelCase, функции и методы в lowercase_with_underscores.
- Избегайте экзотических кодировок и нелатинских идентификаторов.
