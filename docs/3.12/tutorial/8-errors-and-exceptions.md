# 8. Ошибки и исключения

[Оригинал](https://docs.python.org/3.12/tutorial/errors.html)

Ошибки делятся на два типа: синтаксические ошибки (`SyntaxError`) и исключения.

## 8.1. Синтаксические ошибки

Наиболее распространённые ошибки возникают из-за неправильного написания программы. Интерпретатор повторяет строку с ошибкой и показывает стрелочки, указывающие место обнаружения проблемы. Например:

```python
while True print('Привет мир')
```

Ошибка:

```
Файл "<stdin>", строка 1
    while True print('Привет мир')
              ^^^^^^
SyntaxError: неверный синтаксис
```

Проблему часто вызывает отсутствие двоеточия перед функцией `print`.

## 8.2. Исключения

Исключения возникают во время выполнения корректной с точки зрения синтаксиса программы. Примеры исключений:

```python
10 * (1/0)
```

Ошибка:

```
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: деление на ноль
```

Типы встроенных исключений включают:

- `ZeroDivisionError`
- `NameError`
- `TypeError`

Стандартные типы исключений перечислены в разделе [Встроенные исключения](https://docs.python.org/3/library/exceptions.html#bltin-exceptions).

## 8.3. Обработка исключений

Можно обрабатывать выбранные исключения следующим образом:

```python
while True:
    try:
        x = int(input("Пожалуйста введите число: "))
        break
    except ValueError:
        print("Упс! Это было некорректное число. Попробуйте снова...")
```

Механизм работы оператора `try`:

1. Выполняются операторы внутри блока `try`.
2. Если исключение не возникает, блок `except` пропускается.
3. В случае возникновения исключения проверяется соответствие типов исключений.
4. Если тип совпадает, выполняется соответствующий обработчик.
5. Если совпадение не найдено, исключение передается наружу.

Пример обработки нескольких исключений:

```python
try:
    pass
except (RuntimeError, TypeError, NameError):
    pass
```

Также возможно использование конструкции `try`, `except`, `else` и `finally`:

```python
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except OSError:
        print('не удалось открыть', arg)
    else:
        print(arg, 'имеет', len(f.readlines()), 'строки')
        f.close()
```

## 8.4. Генерация исключений

Для принудительного вызова исключения используется оператор `raise`:

```python
raise NameError('HiThere')
```

При вызове класса исключения автоматически создается экземпляр объекта исключения:

```python
raise ValueError  # сокращение для 'raise ValueError()'
```

Перехват и повторная генерация исключения:

```python
try:
    raise NameError('HiThere')
except NameError:
    print('Исключение пролетело мимо!')
    raise
```

## 8.5. Цепочка исключений

Необработанное исключение внутри блока `except` включает предыдущее исключение в сообщение об ошибке:

```python
try:
    open("database.sqlite")
except OSError:
    raise RuntimeError("невозможно обработать ошибку")
```

Цепочку исключений можно указать вручную через конструкцию `raise ... from`:

```python
raise RuntimeError from exc
```

Отключение автоматической цепочки исключений:

```python
raise RuntimeError from None
```

## 8.6. Пользовательские исключения

Пользователи могут создавать собственные классы исключений, наследуя класс `Exception`:

```python
class MyCustomError(Exception):
    pass
```

Обычно такие классы содержат атрибуты, предоставляющие дополнительную информацию об ошибке.

## 8.7. Определение действий очистки

Клаузула `finally` позволяет определить обязательную очистку ресурсов независимо от результата выполнения блока `try`:

```python
try:
    raise KeyboardInterrupt
finally:
    print('До свидания, мир!')
```

Использование `finally` полезно для освобождения внешних ресурсов, таких как файлы или сетевые соединения.

## 8.8. Предопределённые действия очистки

Конструкция `with` обеспечивает автоматическое закрытие файлов после завершения операций:

```python
with open("myfile.txt") as f:
    for line in f:
        print(line, end='')
```

После выполнения файла объект закрывается автоматически.

## 8.9. Генерация и обработка множества несвязанных исключений

Класс `ExceptionGroup` позволяет группировать несколько исключений вместе:

```python
def f():
    excs = [OSError('ошибка 1'), SystemError('ошибка 2')]
    raise ExceptionGroup('были проблемы', excs)

f()
```

Выборочная обработка отдельных исключений группы возможна с помощью конструкции `except*`:

```python
try:
    f()
except* OSError as e:
    print("Возникли ошибки ввода-вывода")
except* SystemError as e:
    print("Возникли системные ошибки")
```

## 8.10. Добавление заметок к исключениям

Метод `add_note()` добавляет контекстную информацию к уже возникшим исключениям:

```python
try:
    raise TypeError('плохой тип')
except Exception as e:
    e.add_note('Добавим немного информации')
    e.add_note('Добавим еще больше информации')
    raise
```

Результатом будет вывод всех заметок после стандартного трассировочного сообщения.
